# 创建型模式

## 工厂方法模式

通过工厂方法模式，我们可以将对象的创建和使用分离开来。这样，我们就可以在不修改现有代码的情况下，更换和增加新的具体产品类。

- ✅ 你可以避免创建者和具体产品之间的紧密耦合。
- ✅ 单一职责原则。你可以将产品创建代码放在程序的单一位置，从而使得代码更容易维护。
- ✅ 开闭原则。无需更改现有客户端代码，你就可以在程序中引入新的产品类型。
- ❌ 应用工厂方法模式需要引入许多新的子类，代码可能会因此变得更复杂。最好的情况是将该模式引入创建者类的现有层次结构中。

### 学习小记

> 未来可能会扩展产品类，但不会修改现有代码。这时，你可以使用工厂方法模式，将对象的创建和使用分离开来。

## 抽象工厂模式

通过抽象工厂模式，我们可以创建一系列相关的对象，而无需指定它们具体的类。

- ✅ 你可以确保同一工厂生成的产品相互匹配。
- ✅ 你可以避免客户端和具体产品代码的耦合。
- ✅ 单一职责原则。 你可以将产品生成代码抽取到同一位置， 使得代码易于维护。
- ✅ 开闭原则。 向应用程序中引入新产品变体时， 你无需修改客户端代码。
- ❌ 由于采用该模式需要向应用中引入众多接口和类， 代码可能会比之前更加复杂。

### 学习小记

> 你需要创建一系列相关或相互依赖的对象，而无需指定它们具体的类。

## 生成器模式

通过生成器模式，我们可以将一个复杂对象的构建与它的表示分离开来， 使得同样的构建过程可以创建不同的表示。

- ✅ 你可以分步创建对象，暂缓创建步骤或递归运行创建步骤。
- ✅ 生成不同形式的产品时，你可以复用相同的制造代码。
- ✅ 单一职责原则。你可以将复杂构造代码从产品的业务逻辑中分离出来。
- ❌ 由于该模式需要新增多个类， 因此代码整体复杂程度会有所增加。

### 学习小记

> 你需要创建复杂对象，而其组成部分经常变化。经常表现为构造函数参数过多，或者构造函数中的代码过于复杂。

## 原型模式

- ✅ 你可以克隆对象， 而无需与它们所属的具体类相耦合。
- ✅ 你可以克隆预生成原型， 避免反复运行初始化代码。
- ✅ 你可以更方便地生成复杂对象。
- ✅ 你可以用继承以外的方式来处理复杂对象的不同配置。
- ❌ 克隆包含循环引用的复杂对象可能会非常麻烦。

### 学习小记

> 通常用于创建复杂对象，或者创建对象的过程比较耗时或复杂， 且创建新对象后，其状态大部分可以由原型对象复制而来。

## 单例模式

- ✅ 你可以保证一个类只有一个实例。
- ✅ 你获得了一个指向该实例的全局访问节点。
- ✅ 仅在首次请求单例对象时对其进行初始化。
- ❌ 违反了单一职责原则。该模式同时解决了两个问题。
- ❌ 单例模式可能掩盖不良设计，比如程序各组件之间相互了解过多等。
- ❌ 该模式在多线程环境下需要进行特殊处理，避免多个线程多次创建单例对象。
- ❌ 单例的客户端代码单元测试可能会比较困难，因为许多测试框架以基于继承的方式创建模拟对象。 由于单例类的构造函数是私有的， 而且绝大部分语言无法重写静态方法， 所以你需要想出仔细考虑模拟单例的方法。 要么干脆不编写测试代码， 或者不使用单例模式。

### 学习小记

> 需要考虑线程安全问题，一般使用饿汉式或者静态内部类的方式，但是也可以使用双重检查锁定的方式。
